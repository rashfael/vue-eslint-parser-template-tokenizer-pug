const fs = require('fs')
const path = require('path')
const { convert: html2Pug } = require('xhtml2pug')
const { parse: parseVue } = require('@vue/compiler-dom')
const SOURCE_BASE_PATH = path.resolve(__dirname, '../tests/fixtures/eslint-plugin-vue/tests/lib/rules/')
const TARGET_BASE_PATH = path.resolve(__dirname, '../tests/eslint-plugin-vue/rules/')

const ESLINT_PLUGIN_VUE_GIT_REF = fs.readFileSync(path.resolve(__dirname, '../.git/modules/tests/fixtures/eslint-plugin-vue/refs/heads/master'), 'utf8').trim()

function getHeader (testname) {
	return `// AUTOGENERATED FROM https://github.com/vuejs/eslint-plugin-vue/blob/${ESLINT_PLUGIN_VUE_GIT_REF}/tests/lib/rules/${testname}.js @${new Date().toISOString()}\n`
}

const IGNORE_TESTS = [
	'array-bracket-newline',
	'html-comment-content-newline',
	'html-comment-content-spacing',
	'html-comment-indent',
	'html-indent',
	'multiline-html-element-content-newline',
	'no-irregular-whitespace', // will probably die horribly
	'no-parsing-error', // need to do own pug parser tests

	// tests without templates
	'no-restricted-call-after-await',
	'script-indent',
]

const ruleTests = fs.readdirSync(SOURCE_BASE_PATH).filter(file => file.endsWith('.js')).map(file => file.replace('.js', '')).filter(file => !IGNORE_TESTS.includes(file))

function stripIndent (code) {
	const match = code.match(/^[ \t]*(?=\S)/gm)
	if (match[0] === '') match.shift() // ignore first line if not indented
	const indent = match && match.length ? match.reduce((i, a) => Math.min(i, a.length), Infinity) : 0
	if (indent === 0) return code
	return code.replace(new RegExp('^[ \\t]{' + indent + '}', 'gm'), '')
}

function convertCode (code) {
	try {
		const ast = parseVue(code)
		for (const node of ast.children) {
			if (node.tag !== 'template' || node.children.length === 0) continue
			const templateContent = code.slice(
				node.children[0].loc.start.offset,
				node.children[node.children.length - 1].loc.end.offset
			)
			let convertedTemplate = html2Pug(stripIndent(templateContent), {
				bodyLess: true,
				parser: 'vue'
			})
			// fix borked empty attributes
			convertedTemplate = convertedTemplate
				.replaceAll('=,', '="",')
				.replaceAll(/([^\\])([`$])/g, '$1\\$2')
				.replaceAll(/([^\\])([`$])/g, '$1\\$2') // MULTIPASS
				.trim()
			const isMultiline = convertedTemplate.includes('\n')
			code = code.slice(0, node.loc.start.offset) +
			'<template lang="pug"' +
			code.slice(node.loc.start.offset + 9, node.children[0].loc.start.offset).trimEnd() +
			(isMultiline ? '\n' : '') +
			convertedTemplate +
			(isMultiline ? '\n' : '') +
			code.slice(node.children[node.children.length - 1].loc.end.offset).trim()
		}
		return code
	} catch (error) {
		return '<!-- CONVERT ERROR -->' + error.message.replaceAll(/([^\\])`/g, '$1\\`') + code
	}
}

for (const testname of ruleTests) {
	let test = fs.readFileSync(path.join(SOURCE_BASE_PATH, testname + '.js'), 'utf8')
	const target = path.join(TARGET_BASE_PATH, testname + '.js')
	try {
		const targetContent = fs.readFileSync(target, 'utf8')
		if (targetContent.startsWith('// SKIP AUTOGENERATION')) {
			console.log('Skipping rule:', testname)
			continue
		}
	} catch (error) {}
	console.log('Generating test for rule:', testname)

	// some lazy replaces
	test = test
		.replace('const rule = ', 'const path = require(\'path\')\nconst rule = ')
		.replaceAll('require(\'../../../lib', 'require(\'../../fixtures/eslint-plugin-vue/lib')
		.replace('require(\'../../eslint-compat', 'require(\'../../fixtures/eslint-plugin-vue/tests/eslint-compat')
		.replaceAll(/parserOptions: {(.*)}/g, 'parserOptions: { $1, templateTokenizer: { pug: path.resolve(__dirname, \'../../../\')}}')
		// .replaceAll(/(code|output): ''|^(?!.*\/\/)(.*?)(code|output):\s*(['"`])(.*?[^\\])\4/gs, (match, bad, lineStart, attribute, quotes, code) => {
		// 	if (!code) return match
		// 	return `${lineStart}${attribute}: \`${convertCode(code)}\``
		// })
		// try to get simple test cases
		.replaceAll(/^(?!.*\/\/)(.*?)(['"`])(<template>[^'"`](.|\n)*?[^\\])\2/gm, (match, lineStart, quotes, code) => {
			return `${lineStart}\`${convertCode(code)}\``
		})
	fs.writeFileSync(target, getHeader(testname) + test)
}
