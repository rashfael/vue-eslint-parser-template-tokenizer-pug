const fs = require('fs')
const path = require('path')
const { convert: html2Pug } = require('xhtml2pug')
const { parse: parseVue } = require('@vue/compiler-dom')
const SOURCE_BASE_PATH = path.resolve(__dirname, '../tests/fixtures/eslint-plugin-vue/tests/lib/rules/')
const TARGET_BASE_PATH = path.resolve(__dirname, '../tests/eslint-plugin-vue/rules/')

const ESLINT_PLUGIN_VUE_GIT_REF = fs.readFileSync(path.resolve(__dirname, '../.git/modules/tests/fixtures/eslint-plugin-vue/refs/heads/master'), 'utf8').trim()

function getHeader (testname) {
	return `// AUTOGENERATED FROM https://github.com/vuejs/eslint-plugin-vue/blob/${ESLINT_PLUGIN_VUE_GIT_REF}/tests/lib/rules/${testname}.js\n`
}

const IGNORE_TESTS = [
	'array-bracket-newline',
	'comment-directive', // invalid syntax breaks the autoconverter
	'html-closing-bracket-spacing',
	'html-closing-bracket-newline',
	'html-comment-content-newline',
	'html-comment-content-spacing',
	'html-comment-indent',
	'html-end-tags',
	'html-indent',
	'html-self-closing',
	'multiline-html-element-content-newline',
	'no-irregular-whitespace', // will probably die horribly
	'no-parsing-error', // need to do own pug parser tests
	'component-name-in-template-casing', // fixes break pug
	'max-attributes-per-line', // fixes break pug
	'max-len', // fixes break pug
	'no-child-content', // does not clean up whitespace, but this might be because we're not using HTMLWhitespace
	'no-deprecated-slot-attribute', // fixing does not remove trailing commas
	'no-multi-spaces', // Error type should be HTMLIdentifier, found PugIdentifier

	// tests without template content rules
	'block-lang',
	'no-restricted-call-after-await',
	'script-indent',
	'component-api-style',
	'component-definition-name-casing',
	'component-options-name-casing',
	'component-tags-order',
	'experimental-script-setup-vars',
	'jsx-uses-vars',
	'multi-word-component-names',
	'name-property-casing',
	'new-line-between-multi-line-property',
	'next-tick-style',
	'no-arrow-functions-in-watch',
	'no-async-in-computed-properties',
	'no-boolean-default',
	'no-computed-properties-in-data',
	'no-deprecated-data-object-declaration',
	'no-deprecated-destroyed-lifecycle',
	'no-deprecated-events-api',
	'no-deprecated-vue-config-keycodes',
	'no-dupe-keys',
	'no-empty-component-block',
	'no-export-in-script-setup',
	'no-expose-after-await',
	'no-invalid-model-keys',
	'no-lifecycle-after-await',
	'no-multiple-slot-args',
	'no-potential-component-option-typo',
	'no-ref-as-operand',
	'no-reserved-props',
	'no-restricted-block',
	'no-restricted-component-options',
	'no-restricted-props',
	'no-setup-props-destructure',
	'no-shared-component-data',
	'no-side-effects-in-computed-properties',
	'one-component-per-file',
	'prefer-import-from-vue',
	'prop-name-casing',
	'require-direct-export',
	'require-expose',
	'require-name-property',
	'require-prop-type-constructor',
	'require-render-return',
	'require-slots-as-functions',
	'return-in-computed-property',
	'return-in-emits-validator',
	'valid-define-emits',
	'valid-define-props',
	'valid-next-tick',
]

const ruleTests = fs.readdirSync(SOURCE_BASE_PATH).filter(file => file.endsWith('.js')).map(file => file.replace('.js', '')).filter(file => !IGNORE_TESTS.includes(file))

function stripIndent (code) {
	const match = code.match(/^[ \t]*(?=\S)/gm)
	if (match[0] === '') match.shift() // ignore first line if not indented
	const indent = match && match.length ? match.reduce((i, a) => Math.min(i, a.length), Infinity) : 0
	if (indent === 0) return code
	return code.replace(new RegExp('^[ \\t]{' + indent + '}', 'gm'), '')
}

function convertCode (code) {
	try {
		const ast = parseVue(code)
		for (const node of ast.children) {
			if (node.tag !== 'template' || node.children.length === 0) continue
			const templateContent = code.slice(
				node.children[0].loc.start.offset,
				node.children[node.children.length - 1].loc.end.offset
			)
			let convertedTemplate = html2Pug(stripIndent(templateContent), {
				bodyLess: true,
				parser: 'vue'
			})
			// fix borked empty attributes
			convertedTemplate = convertedTemplate
				.replaceAll('=,', '="",')
				.replaceAll(/([^\\])([`$])/g, '$1\\$2')
				.replaceAll(/([^\\])([`$])/g, '$1\\$2') // MULTIPASS
				.trim()
			const isMultiline = convertedTemplate.includes('\n')
			code = code.slice(0, node.loc.start.offset) +
			'<template lang="pug"' +
			code.slice(node.loc.start.offset + 9, node.children[0].loc.start.offset).trimEnd() +
			(isMultiline ? '\n' : '') +
			convertedTemplate +
			(isMultiline ? '\n' : '') +
			code.slice(node.children[node.children.length - 1].loc.end.offset).trim()
		}
		return code
	} catch (error) {
		return '<!-- CONVERT ERROR -->' + error.message.replaceAll(/([^\\])`/g, '$1\\`') + code
	}
}

for (const testname of ruleTests) {
	let test = fs.readFileSync(path.join(SOURCE_BASE_PATH, testname + '.js'), 'utf8')
	const target = path.join(TARGET_BASE_PATH, testname + '.js')
	try {
		const targetContent = fs.readFileSync(target, 'utf8')
		if (targetContent.startsWith('// SKIP AUTOGENERATION')) {
			console.log('Skipping rule:', testname)
			continue
		}
	} catch (error) {}
	console.log('Generating test for rule:', testname)

	// some lazy replaces
	test = test
		.replace('const rule = ', 'const path = require(\'path\')\nconst rule = ')
		.replaceAll('require(\'../../../lib', 'require(\'../../fixtures/eslint-plugin-vue/lib')
		.replace('require(\'../../eslint-compat', 'require(\'../../fixtures/eslint-plugin-vue/tests/eslint-compat')
		.replaceAll(/parserOptions: {(.*?)}/gs, 'parserOptions: { $1, templateTokenizer: { pug: path.resolve(__dirname, \'../../../\')}}')
		// .replaceAll(/(code|output): ''|^(?!.*\/\/)(.*?)(code|output):\s*(['"`])(.*?[^\\])\4/gs, (match, bad, lineStart, attribute, quotes, code) => {
		// 	if (!code) return match
		// 	return `${lineStart}${attribute}: \`${convertCode(code)}\``
		// })
		// try to get simple test cases
		.replaceAll(/^(?!.*[^:]\/\/)(.*?)(['"`])(\s*?<template>[^'"`](.|\n)*?[^\\])\2/gm, (match, lineStart, quotes, code) => {
			return `${lineStart}\`${convertCode(code)}\``
		})
		// try to catch stragglers with other tags befor template
		.replaceAll(/^ *<template>.*?<\/template>/gms, match => convertCode(match))
	fs.writeFileSync(target, getHeader(testname) + test)
}
